# .github/workflows/video-server-fixed.yml
name: Video Generation Server with Public URL

on: 
  workflow_dispatch:
    inputs:
      server_duration:
        description: 'Server duration (minutes)'
        required: false
        default: '25'

jobs:
  server:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.server_duration || 25 }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: |
        pip install --upgrade pip
        pip install torch --index-url https://download.pytorch.org/whl/cpu
        pip install diffusers transformers
        pip install fastapi uvicorn pyngrok
        pip install opencv-python imageio imageio-ffmpeg pillow
        
    - name: Create ngrok config directory and file
      run: |
        mkdir -p ~/.config/ngrok
        echo "authtoken: ${{ secrets.NGROK_AUTH_TOKEN }}" > ~/.config/ngrok/ngrok.yml
        echo "âœ… Ngrok config created with auth token"
        
    - name: Verify ngrok config
      run: |
        echo "Checking ngrok config..."
        cat ~/.config/ngrok/ngrok.yml
        echo "âœ… Ngrok config verified"
        
    - name: Create simple video server
      run: |
        cat > server.py << 'EOF'
        from fastapi import FastAPI, HTTPException
        from fastapi.responses import FileResponse, JSONResponse
        from pydantic import BaseModel
        import uvicorn
        import threading
        import time
        import os
        import subprocess
        import requests
        from datetime import datetime
        
        app = FastAPI(title="Video Generator", version="1.0")
        
        class VideoRequest(BaseModel):
            prompt: str = "A teddy bear waving"
            steps: int = 10
            frames: int = 4
            height: int = 64
            width: int = 64
        
        # Store requests
        requests_log = []
        
        @app.get("/")
        async def home():
            return {
                "message": "ðŸš€ Video Generation Server", 
                "status": "running",
                "endpoints": {
                    "health": "GET /health",
                    "generate": "POST /generate",
                    "download": "GET /download/{filename}",
                    "requests": "GET /requests"
                },
                "timestamp": datetime.now().isoformat()
            }
        
        @app.get("/health")
        async def health():
            return {"status": "healthy", "timestamp": datetime.now().isoformat()}
        
        @app.post("/generate")
        async def generate_video(request: VideoRequest):
            start_time = time.time()
            request_id = f"req_{int(time.time())}"
            
            # Log request
            requests_log.append({
                "id": request_id,
                "timestamp": datetime.now().isoformat(),
                "prompt": request.prompt,
                "status": "processing"
            })
            
            try:
                print(f"ðŸŽ¬ Generating video: {request.prompt}")
                
                # Import inside function to avoid startup delay
                from diffusers import DiffusionPipeline
                from diffusers.utils import export_to_video
                
                # Load model
                pipe = DiffusionPipeline.from_pretrained('damo-vilab/text-to-video-ms-1.7b')
                pipe = pipe.to('cpu')
                
                # Generate video
                video_frames = pipe(
                    request.prompt,
                    num_inference_steps=request.steps,
                    num_frames=request.frames,
                    height=request.height,
                    width=request.width,
                ).frames[0]
                
                # Save video
                filename = f"video_{request_id}.mp4"
                os.makedirs("videos", exist_ok=True)
                video_path = f"videos/{filename}"
                export_to_video(video_frames, video_path)
                
                processing_time = time.time() - start_time
                
                # Update log
                for req in requests_log:
                    if req["id"] == request_id:
                        req["status"] = "completed"
                        req["filename"] = filename
                        req["processing_time"] = round(processing_time, 2)
                        break
                
                return {
                    "status": "success",
                    "message": "Video generated successfully!",
                    "data": {
                        "download_url": f"/download/{filename}",
                        "prompt": request.prompt,
                        "processing_time": round(processing_time, 2),
                        "filename": filename,
                        "request_id": request_id
                    },
                    "timestamp": datetime.now().isoformat()
                }
                
            except Exception as e:
                # Update log with error
                for req in requests_log:
                    if req["id"] == request_id:
                        req["status"] = "error"
                        req["error"] = str(e)
                        break
                
                raise HTTPException(
                    status_code=500,
                    detail={
                        "status": "error",
                        "message": f"Video generation failed: {str(e)}",
                        "request_id": request_id,
                        "timestamp": datetime.now().isoformat()
                    }
                )
        
        @app.get("/download/{filename}")
        async def download_video(filename: str):
            video_path = f"videos/{filename}"
            if os.path.exists(video_path):
                return FileResponse(
                    video_path,
                    media_type='video/mp4',
                    filename=filename
                )
            raise HTTPException(status_code=404, detail="Video not found")
        
        @app.get("/requests")
        async def get_requests():
            return {
                "status": "success",
                "total_requests": len(requests_log),
                "requests": requests_log
            }
        
        def start_server():
            uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
        
        if __name__ == "__main__":
            # Create videos directory
            os.makedirs("videos", exist_ok=True)
            
            # Start ngrok in background
            print("ðŸš€ Starting ngrok tunnel...")
            ngrok_process = subprocess.Popen(
                ["ngrok", "http", "8000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            # Wait for ngrok to start
            time.sleep(5)
            
            # Get public URL from ngrok API
            try:
                response = requests.get("http://localhost:4040/api/tunnels")
                tunnels = response.json()
                public_url = tunnels["tunnels"][0]["public_url"]
                print(f"ðŸŒ PUBLIC URL: {public_url}")
                
                # Write URL to file
                with open("public_url.txt", "w") as f:
                    f.write(public_url)
                    
            except Exception as e:
                print(f"âŒ Failed to get ngrok URL: {e}")
                public_url = "Unable to get URL"
            
            # Start FastAPI server in thread
            server_thread = threading.Thread(target=start_server)
            server_thread.daemon = True
            server_thread.start()
            
            print("âœ… Server started successfully!")
            print("â° Server will run for 25 minutes...")
            print("ðŸ“± Use the public URL above to access your server")
            
            # Keep alive
            try:
                time.sleep(60 * 25)  # 25 minutes
            except KeyboardInterrupt:
                pass
            finally:
                ngrok_process.terminate()
                print("ðŸ›‘ Server stopped")
        EOF

    - name: Start server and get public URL
      run: |
        python server.py &
        SERVER_PID=$!
        echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
        sleep 10
        
        # Try to get public URL
        echo "ðŸ” Getting public URL..."
        if [ -f "public_url.txt" ]; then
            PUBLIC_URL=$(cat public_url.txt)
            echo "PUBLIC_URL=$PUBLIC_URL" >> $GITHUB_ENV
            echo "âœ… Got URL from file: $PUBLIC_URL"
        else
            # Try ngrok API
            echo "Trying ngrok API..."
            sleep 5
            if curl -s http://localhost:4040/api/tunnels > tunnels.json 2>/dev/null; then
                PUBLIC_URL=$(python3 -c "import json; print(json.load(open('tunnels.json'))['tunnels'][0]['public_url'])")
                echo "PUBLIC_URL=$PUBLIC_URL" >> $GITHUB_ENV
                echo "âœ… Got URL from API: $PUBLIC_URL"
            else
                echo "âŒ Could not get public URL"
                echo "PUBLIC_URL=https://ngrok-failed.com" >> $GITHUB_ENV
            fi
        fi

    - name: Test server endpoints
      run: |
        echo "Testing server at: $PUBLIC_URL"
        if curl -f "$PUBLIC_URL/health" 2>/dev/null; then
            echo "âœ… Health check passed"
        else
            echo "âŒ Health check failed"
        fi
        
        if curl -f "$PUBLIC_URL/" 2>/dev/null; then
            echo "âœ… Root endpoint working"
        else
            echo "âŒ Root endpoint failed"
        fi

    - name: Display server information
      run: |
        echo ""
        echo "==================================================="
        echo "ðŸŽ‰ VIDEO GENERATION SERVER IS LIVE!"
        echo "==================================================="
        echo ""
        echo "ðŸŒ PUBLIC URL: $PUBLIC_URL"
        echo ""
        echo "ðŸ“‹ HOW TO USE:"
        echo "   1. Click or copy the URL above"
        echo "   2. You'll see API documentation"
        echo "   3. Test the /generate endpoint"
        echo ""
        echo "ðŸ”§ QUICK TEST:"
        echo "   curl -X POST '$PUBLIC_URL/generate' \\"
        echo "     -H 'Content-Type: application/json' \\"
        echo "     -d '{\"prompt\": \"A teddy bear waving\"}'"
        echo ""
        echo "â° Server will run for 25 minutes"
        echo "==================================================="
        
        # Create workflow summary
        echo "## ðŸŽ¬ Video Generation Server" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŒ Public URL: $PUBLIC_URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Quick Start:**" >> $GITHUB_STEP_SUMMARY
        echo '```bash' >> $GITHUB_STEP_SUMMARY
        echo "curl -X POST '$PUBLIC_URL/generate' \\" >> $GITHUB_STEP_SUMMARY
        echo "  -H 'Content-Type: application/json' \\" >> $GITHUB_STEP_SUMMARY
        echo "  -d '{\"prompt\": \"A cute teddy bear\"}'" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

    - name: Keep server running
      run: |
        echo "â° Server running at: $PUBLIC_URL"
        echo "ðŸ•’ Will auto-stop in 25 minutes..."
        sleep 1500  # 25 minutes

    - name: Cleanup
      if: always()
      run: |
        echo "ðŸ§¹ Cleaning up..."
        kill $SERVER_PID 2>/dev/null || true
        pkill ngrok 2>/dev/null || true
        echo "âœ… Cleanup complete"
