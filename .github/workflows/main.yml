# .github/workflows/fast-video-server.yml
name: Fast Video Generation Server

on: [workflow_dispatch]

jobs:
  generate:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: |
        pip install --upgrade pip
        pip install torch --index-url https://download.pytorch.org/whl/cpu
        pip install diffusers transformers fastapi uvicorn pydantic
        pip install opencv-python imageio imageio-ffmpeg pillow pyngrok
        
    - name: Setup ngrok for public URL
      run: |
        pip install pyngrok
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
        echo "ðŸŒ Setting up public tunnel..."
        
    - name: Create FastAPI server
      run: |
        cat > video_server.py << 'EOF'
        from fastapi import FastAPI, HTTPException
        from fastapi.responses import FileResponse, JSONResponse
        from pydantic import BaseModel
        from diffusers import DiffusionPipeline
        from diffusers.utils import export_to_video
        import uvicorn
        import threading
        from pyngrok import ngrok
        import time
        import os
        from datetime import datetime
        import logging
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        app = FastAPI(title="Video Generation Server", version="1.0.0")
        
        # Store requests
        requests_log = []
        
        class VideoRequest(BaseModel):
            prompt: str
            num_steps: int = 10
            num_frames: int = 4
            height: int = 64
            width: int = 64
        
        class VideoResponse(BaseModel):
            status: str
            message: str
            video_url: str = None
            download_url: str = None
            prompt: str = None
            processing_time: float = None
            timestamp: str
        
        @app.get("/")
        async def root():
            """Root endpoint with server info"""
            return {
                "status": "success",
                "message": "ðŸš€ Video Generation Server is Running!",
                "endpoints": {
                    "health": "/health",
                    "generate_video": "/generate (POST)",
                    "download_video": "/video/{filename}",
                    "server_info": "/info"
                },
                "usage": "POST to /generate with {'prompt': 'your text here'}",
                "timestamp": datetime.now().isoformat()
            }
        
        @app.get("/health")
        async def health():
            """Health check endpoint"""
            return {"status": "healthy", "timestamp": datetime.now().isoformat()}
        
        @app.get("/info")
        async def server_info():
            """Server information"""
            return {
                "status": "success",
                "server": "Fast Video Generation API",
                "model": "damo-vilab/text-to-video-ms-1.7b",
                "max_duration": "30 minutes",
                "timestamp": datetime.now().isoformat()
            }
        
        @app.post("/generate", response_model=VideoResponse)
        async def generate_video(request: VideoRequest):
            """Generate video from text prompt"""
            start_time = time.time()
            
            # Log the request
            requests_log.append({
                "timestamp": datetime.now().isoformat(),
                "prompt": request.prompt,
                "status": "processing"
            })
            
            try:
                logger.info(f"Generating video for: {request.prompt}")
                
                # Load model (in production, you'd initialize this once)
                pipe = DiffusionPipeline.from_pretrained('damo-vilab/text-to-video-ms-1.7b')
                pipe = pipe.to('cpu')
                
                # Generate video
                video_frames = pipe(
                    request.prompt,
                    num_inference_steps=request.num_steps,
                    num_frames=request.num_frames,
                    height=request.height,
                    width=request.width,
                ).frames[0]
                
                # Save video
                filename = f"video_{int(time.time())}.mp4"
                os.makedirs("videos", exist_ok=True)
                video_path = f"videos/{filename}"
                export_to_video(video_frames, video_path)
                
                processing_time = time.time() - start_time
                
                # Update request log
                requests_log[-1]["status"] = "completed"
                requests_log[-1]["filename"] = filename
                requests_log[-1]["processing_time"] = processing_time
                
                response = VideoResponse(
                    status="success",
                    message="Video generated successfully!",
                    video_url=f"/video/{filename}",
                    download_url=f"/download/{filename}",
                    prompt=request.prompt,
                    processing_time=round(processing_time, 2),
                    timestamp=datetime.now().isoformat()
                )
                
                logger.info(f"Video generated: {filename} in {processing_time:.2f}s")
                return response
                
            except Exception as e:
                logger.error(f"Video generation failed: {str(e)}")
                requests_log[-1]["status"] = "error"
                requests_log[-1]["error"] = str(e)
                
                raise HTTPException(
                    status_code=500,
                    detail={
                        "status": "error",
                        "message": f"Video generation failed: {str(e)}",
                        "timestamp": datetime.now().isoformat()
                    }
                )
        
        @app.get("/video/{filename}")
        async def get_video(filename: str):
            """Serve video file"""
            video_path = f"videos/{filename}"
            if os.path.exists(video_path):
                return FileResponse(
                    video_path,
                    media_type='video/mp4',
                    filename=filename
                )
            else:
                raise HTTPException(status_code=404, detail="Video not found")
        
        @app.get("/download/{filename}")
        async def download_video(filename: str):
            """Download video file"""
            video_path = f"videos/{filename}"
            if os.path.exists(video_path):
                return FileResponse(
                    video_path,
                    media_type='video/mp4',
                    filename=filename
                )
            else:
                raise HTTPException(status_code=404, detail="Video not found")
        
        @app.get("/requests")
        async def get_requests():
            """Get all request logs"""
            return {
                "status": "success",
                "total_requests": len(requests_log),
                "requests": requests_log
            }
        
        def start_server():
            """Start the FastAPI server"""
            uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
        
        if __name__ == "__main__":
            # Create videos directory
            os.makedirs("videos", exist_ok=True)
            
            # Start ngrok tunnel
            print("ðŸš€ Starting ngrok tunnel...")
            public_url = ngrok.connect(8000, bind_tls=True)
            print(f"ðŸŒ PUBLIC URL: {public_url}")
            print("ðŸ“‹ Use this URL to access your video generation server!")
            print("â° Server will run for 25 minutes...")
            
            # Write URL to file for the workflow
            with open("public_url.txt", "w") as f:
                f.write(public_url)
            
            # Start server in a thread
            server_thread = threading.Thread(target=start_server)
            server_thread.daemon = True
            server_thread.start()
            
            # Keep the main thread alive
            try:
                # Run for 25 minutes (workflow timeout is 30 minutes)
                time.sleep(1500)
            except KeyboardInterrupt:
                print("Shutting down server...")
        EOF

    - name: Start server with public URL
      run: |
        python video_server.py &
        SERVER_PID=$!
        echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
        sleep 10
        
        # Get the public URL
        if [ -f "public_url.txt" ]; then
            PUBLIC_URL=$(cat public_url.txt)
            echo "PUBLIC_URL=$PUBLIC_URL" >> $GITHUB_ENV
            echo "ðŸš€ Server is live at: $PUBLIC_URL"
        else
            # Fallback: get URL from ngrok API
            TUNNELS=$(curl -s localhost:4040/api/tunnels)
            PUBLIC_URL=$(echo $TUNNELS | python -c "import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])")
            echo "PUBLIC_URL=$PUBLIC_URL" >> $GITHUB_ENV
            echo "ðŸš€ Server is live at: $PUBLIC_URL"
        fi
        
        # Test the server
        echo "Testing server endpoints..."
        curl -f $PUBLIC_URL/health && echo "âœ… Health check passed" || echo "âŒ Health check failed"
        curl -f $PUBLIC_URL/info && echo "âœ… Server info endpoint working" || echo "âŒ Info endpoint failed"

    - name: Display clickable URL
      run: |
        echo "================================================"
        echo "ðŸŽ‰ VIDEO GENERATION SERVER IS NOW LIVE!"
        echo "================================================"
        echo ""
        echo "ðŸŒ CLICK THIS LINK TO ACCESS YOUR SERVER:"
        echo "   $PUBLIC_URL"
        echo ""
        echo "ðŸ“‹ QUICK START:"
        echo "   1. Click the link above"
        echo "   2. You'll see the API documentation"
        echo "   3. Use the /generate endpoint to create videos"
        echo ""
        echo "ðŸ”§ ENDPOINTS:"
        echo "   â€¢ $PUBLIC_URL/          - Server info"
        echo "   â€¢ $PUBLIC_URL/health    - Health check"
        echo "   â€¢ $PUBLIC_URL/generate  - Generate videos (POST)"
        echo "   â€¢ $PUBLIC_URL/requests  - View all requests"
        echo ""
        echo "ðŸ’¡ EXAMPLE USAGE:"
        echo "   curl -X POST $PUBLIC_URL/generate \\"
        echo "     -H \"Content-Type: application/json\" \\"
        echo "     -d '{\"prompt\": \"A teddy bear waving\"}'"
        echo ""
        echo "â° Server will automatically shut down after 25 minutes"
        echo "================================================"

    - name: Keep server running
      run: |
        echo "â° Server will run for 25 minutes..."
        echo "ðŸ“± Access your server at: $PUBLIC_URL"
        echo "ðŸ”„ Check the workflow logs for any generation requests"
        sleep 1500  # 25 minutes

    - name: Cleanup
      if: always()
      run: |
        echo "ðŸ§¹ Cleaning up..."
        kill $SERVER_PID 2>/dev/null || true
        pkill ngrok 2>/dev/null || true
        echo "Server stopped"
